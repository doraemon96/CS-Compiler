
==================== FINAL INTERFACE ====================
2018-12-06 21:30:41.213105114 UTC

interface HaskTiger-0.1.0.0-ICRikAExwdr6IYW5QWtTsY:State 8043
  interface hash: 27b64a07ccf025b50e6ceaf77e6b9c00
  ABI hash: 1a43ffa078c1fda9b1eb915e7dbaa853
  export-list hash: 4352251c8724d95158cb6eed27708eb9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 84a707957232ceed2ddebd5ca4ca265a
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  State.get
  State.modify
  State.put
  State.State{State.St runSt}
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Control.Arrow ce43199b5356a11ee2a8317f0ec30aee
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
063131fc2fe77171d0a98ac76a9c2b40
  $fApplicativeState :: GHC.Base.Applicative (State.State s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (State.State s)
                  (State.$fFunctorState @ s)
                  (State.$fApplicativeState5 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (State.N:State[0] <s>_R <a>_R))
                  (State.$fApplicativeState4 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <State.State s (a -> b)>_R
                   ->_R <State.State s a>_R
                   ->_R Sym (State.N:State[0] <s>_R <b>_R))
                  (\ @ a @ b @ c -> State.$fApplicativeState3 @ c @ b @ s @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <State.State s a>_R
                   ->_R <State.State s b>_R
                   ->_R Sym (State.N:State[0] <s>_R <c>_R))
                  (\ @ a @ b -> State.$fApplicativeState2 @ b @ a @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <State.State s a>_R
                   ->_R <State.State s b>_R
                   ->_R Sym (State.N:State[0] <s>_R <b>_R))
                  (\ @ a @ b -> State.$fApplicativeState1 @ b @ a @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <State.State s a>_R
                   ->_R <State.State s b>_R
                   ->_R Sym (State.N:State[0] <s>_R <a>_R)) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fApplicativeState1 ::
    State.State s a -> State.State s b -> s -> (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><L,1*C1(U(A,1*U))><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   @ s
                   (x :: State.State s a)
                   (eta :: State.State s b)
                   (eta1 :: s) ->
                 let {
                   ds1 :: (a, s) = x `cast` (State.N:State[0] <s>_R <a>_R) eta1
                 } in
                 (case ds1 of wild { (,) x1 y -> x1 },
                  case eta `cast` (State.N:State[0] <s>_R <b>_R)
                         (case ds1 of wild { (,) x1 y -> y }) of wild { (,) x' s'' ->
                  s'' })) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fApplicativeState2 ::
    State.State s a -> State.State s b -> s -> (b, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   @ s
                   (a1 :: State.State s a)
                   (a2 :: State.State s b)
                   (eta :: s) ->
                 let {
                   ds :: (b, s)
                   = a2 `cast` (State.N:State[0] <s>_R <b>_R)
                       (case a1 `cast` (State.N:State[0] <s>_R <a>_R)
                               eta of wild { (,) x y ->
                        y })
                 } in
                 (case ds of wild { (,) x' s'' -> x' },
                  case ds of wild { (,) x' s'' -> s'' })) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fApplicativeState3 ::
    (a -> b -> c) -> State.State s a -> State.State s b -> s -> (c, s)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U))><L,1*C1(U(1*U,1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ c
                   @ b
                   @ s
                   @ a
                   (w :: a -> b -> c)
                   (w1 :: State.State s a)
                   (w2 :: State.State s b)
                   (w3 :: s) ->
                 let {
                   ds1 :: (a, s) = w1 `cast` (State.N:State[0] <s>_R <a>_R) w3
                 } in
                 let {
                   ds :: (b, s)
                   = w2 `cast` (State.N:State[0] <s>_R <b>_R)
                       (case ds1 of wild { (,) x y -> y })
                 } in
                 (w (case ds1 of wild { (,) x y -> x })
                    (case ds of wild { (,) x' s'' -> x' }),
                  case ds of wild { (,) x' s'' -> s'' })) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fApplicativeState4 ::
    State.State s (a -> b) -> State.State s a -> s -> (b, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*C1(U),1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   @ b
                   (w :: State.State s (a -> b))
                   (w1 :: State.State s a)
                   (w2 :: s) ->
                 let {
                   ds :: (a -> b, s) = w `cast` (State.N:State[0] <s>_R <a -> b>_R) w2
                 } in
                 let {
                   ds1 :: (a, s)
                   = w1 `cast` (State.N:State[0] <s>_R <a>_R)
                       (case ds of wild { (,) f' s' -> s' })
                 } in
                 (case ds of wild { (,) f' s' ->
                  f' (case ds1 of wild1 { (,) x' s'' -> x' }) },
                  case ds1 of wild { (,) x' s'' -> s'' })) -}
a2bf07a5ea22c8d65aa242b2c6cb4ece
  $fApplicativeState5 :: a -> s -> (a, s)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ s @ a (a1 :: a) (s1 :: s) -> (a1, s1)) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fFunctorState :: GHC.Base.Functor (State.State s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (State.State s)
                  (State.$fFunctorState2 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R <State.State s a>_R
                   ->_R Sym (State.N:State[0] <s>_R <b>_R))
                  (\ @ a @ b -> State.$fFunctorState1 @ s @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <State.State s b>_R
                   ->_R Sym (State.N:State[0] <s>_R <a>_R)) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fFunctorState1 :: a -> State.State s b -> s -> (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U(A,1*U))><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ s @ b @ a (x :: a) (m :: State.State s b) (s' :: s) ->
                 (x,
                  case m `cast` (State.N:State[0] <s>_R <b>_R)
                         s' of wild { (,) x1 y ->
                  y })) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fFunctorState2 :: (a -> b) -> State.State s a -> s -> (b, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ s @ a @ b (f :: a -> b) (m :: State.State s a) (s' :: s) ->
                 let {
                   ds1 :: (a, s) = m `cast` (State.N:State[0] <s>_R <a>_R) s'
                 } in
                 (f (case ds1 of wild { (,) x y -> x }),
                  case ds1 of wild { (,) x y -> y })) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fMonadState :: GHC.Base.Monad (State.State s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (State.State s)
                  (State.$fApplicativeState @ s)
                  (State.$fMonadState1 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <State.State s a>_R
                   ->_R <a -> State.State s b>_R
                   ->_R Sym (State.N:State[0] <s>_R <b>_R))
                  (State.$fMonadState_$c>> @ s)
                  (State.$fApplicativeState5 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (State.N:State[0] <s>_R <a>_R))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (State.State s a)) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fMonadState1 ::
    State.State s a -> (a -> State.State s b) -> s -> (b, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><C(C(S)),1*C1(C1(U(U,U)))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   @ b
                   (x :: State.State s a)
                   (g :: a -> State.State s b)
                   (s1 :: s) ->
                 let {
                   ds :: (a, s) = x `cast` (State.N:State[0] <s>_R <a>_R) s1
                 } in
                 (g (case ds of wild { (,) x' s' -> x' }))
                   `cast`
                 (State.N:State[0] <s>_R <b>_R)
                   (case ds of wild { (,) x' s' -> s' })) -}
063131fc2fe77171d0a98ac76a9c2b40
  $fMonadState_$c>> ::
    State.State s a -> State.State s b -> State.State s b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: State.State s a)
                   (k :: State.State s b)
                   (s1 :: s) ->
                 k `cast` (State.N:State[0] <s>_R <b>_R)
                   (case m1 `cast` (State.N:State[0] <s>_R <a>_R)
                           s1 of wild { (,) x' s' ->
                    s' }))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <State.State s a>_R
                 ->_R <State.State s b>_R
                 ->_R Sym (State.N:State[0] <s>_R <b>_R)) -}
5e64237c35df81b2fcf445ee428ad10e
  $tc'St :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12264281942431631285##
                   1416478816750688475##
                   State.$trModule
                   State.$tc'St2
                   2#
                   State.$tc'St1) -}
1f82b443704531cb28c03817ca47a879
  $tc'St1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
351b7dc7150fd2efbc452a4677e1e701
  $tc'St2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS State.$tc'St3) -}
b29bc393d18eb818690a7ee390d8e335
  $tc'St3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'St"#) -}
2ea236e8a703eb90a479e57b38644a85
  $tcState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8779202341824525890##
                   4796314983493210362##
                   State.$trModule
                   State.$trModule1
                   0#
                   GHC.Types.krep$*->*->*) -}
9f69ba3e73dd35ca1331736c8fa320b5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module State.$trModule3 State.$trModule1) -}
7b83760fe7c3d315462135ea031b15c2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS State.$trModule2) -}
c657612e9ccbf834ba23e55349c907fd
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("State"#) -}
2a6982cca4494d3ed8c41808e57b5edd
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS State.$trModule4) -}
fa21d697a136f1f990fcba7ba21f4c02
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("HaskTiger-0.1.0.0-ICRikAExwdr6IYW5QWtTsY"#) -}
063131fc2fe77171d0a98ac76a9c2b40
  newtype State s v = St {runSt :: s -> (v, s)}
eedd827bd879b498277b598c4652e6d1
  get :: State.State a a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                State.get1
                  `cast`
                (forall (a :: <*>_N). Sym (State.N:State[0] <a>_R <a>_R)) -}
fdda62587b8ab8b53a88f9a76c4f9d77
  get1 :: a -> (a, a)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (s :: a) -> (s, s)) -}
f4aae5de9be5217ef0090b78d1048ff5
  modify :: (s -> s) -> State.State s ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                State.modify1
                  `cast`
                (forall (s :: <*>_N).
                 <s -> s>_R ->_R Sym (State.N:State[0] <s>_R <()>_R)) -}
c98ed14072fa8b10a79cb5de0e94cab2
  modify1 :: (s -> s) -> s -> ((), s)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ s (f :: s -> s) (s1 :: s) -> (GHC.Tuple.(), f s1)) -}
219d9aea06b2f52b64774f52478ee387
  put :: b -> State.State b ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (0, True, True)
                State.put1
                  `cast`
                (forall (b :: <*>_N).
                 <b>_R ->_R Sym (State.N:State[0] <b>_R <()>_R)) -}
48874f06ff34a38bfe52dcb45ac28f85
  put1 :: b -> b -> ((), b)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ b (b1 :: b) (eta :: b) -> (GHC.Tuple.(), b1)) -}
063131fc2fe77171d0a98ac76a9c2b40
  runSt :: State.State s v -> s -> (v, s)
  RecSel Left State.State
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                State.runSt1
                  `cast`
                (forall (s :: <*>_N) (v :: <*>_N).
                 <State.State s v>_R ->_R State.N:State[0] <s>_R <v>_R) -}
063131fc2fe77171d0a98ac76a9c2b40
  runSt1 :: State.State s v -> State.State s v
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ s @ v (ds :: State.State s v) -> ds) -}
instance [safe] GHC.Base.Applicative [State.State]
  = State.$fApplicativeState
instance [safe] GHC.Base.Functor [State.State]
  = State.$fFunctorState
instance [safe] GHC.Base.Monad [State.State] = State.$fMonadState
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

