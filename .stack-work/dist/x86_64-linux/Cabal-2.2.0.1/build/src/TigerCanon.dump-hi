
==================== FINAL INTERFACE ====================
2019-03-18 19:26:29.200440516 UTC

interface HaskTiger-0.1.0.0-ICRikAExwdr6IYW5QWtTsY:TigerCanon 8043
  interface hash: f622ef0abccd8863325dce0c36b5f612
  ABI hash: edfc4c264cfc05594522ee1745a15486
  export-list hash: 655f6360d6e21e01beea73c3edc5759a
  orphan hash: d270e9136f5bcd8ba48dc48e00e3d6d2
  flag hash: 84a707957232ceed2ddebd5ca4ca265a
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  TigerCanon.basicBlocks
  TigerCanon.linearize
  TigerCanon.traceSchedule
module dependencies: State TigerSymbol TigerTemp TigerTree
                     TigerUnique
package dependencies: array-0.5.2.0 base-4.11.1.0* binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 mtl-2.2.2 text-1.2.3.0
                      transformers-0.5.5.0
orphans: text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         HaskTiger-0.1.0.0-ICRikAExwdr6IYW5QWtTsY:TigerUnique
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.0:Data.Text
import  -/  TigerSymbol 8cdb62767ac36bcd684c9f1304d4a564
  exports: da94fd004c9146d1f25642212f80c685
import  -/  TigerTemp 3bc4ed564aeabe58cf535512ec048d33
  exports: 6b85f77b0bcc6e133222675af91d5259
  Label e211b5893645bd99d551cf10a36d620b
  TLGenerator 0da889271ca392648fe70411a9dd5b23
  newLabel 7ba494a2fcb58f1d1a94e5e0774e8507
  newTemp 28e5981eb3c4f40cb3463ab7db349b5a
import  -/  TigerTree b3822817a90e7d3d52e7faf396d1e661
  exports: 18931e72ed30bbeb7fa4b14d3a1cec66
  Binop faf7f6a18bfd79d3c0cf1b8ec84dd76b
  CJump f9c4df5a608857e7e3a13d599af02159
  Call d18418b45fa695bd19aa29089226d8fa
  Const 2e241003f48516223e109f35db44ed4c
  Eseq fb548d788ce5bd7d322c1af9217cb690
  Exp 41dcc78a73675959911b133e79d2016d
  ExpS 3a29f4e7809ae1794504de3052de2e2c
  Jump b42879698d8b5db14f9aa3942d21ed85
  Label bad5c830d864f66bf4d972a5316315a2
  Mem ba2eb85ba7f0ea842ee2e5275f01bfbc
  Move 6ad598cc8ddd68dab64e5fa3758cb7f0
  Name 8925b162f69e6bfb3c7671fa36d1392c
  Seq 41d9a8b50d3a4fca04c5c5c057d51c84
  Stm 41dcc78a73675959911b133e79d2016d
  Temp 49b0bf6180dfc16efae43b0023765e37
  notRel d8676e3678b53c7d85ec6764f416f1eb
import  -/  TigerUnique c609db41e14bf4ada457c59538dc0445
  exports: aa23a62153d42804837397f8b85bb196
  StGen 600da96a6f5c385280c5ea14e80af84e
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.Map.Internal e02d23495520de11b8e9f3c9c93a4d11
import  -/  containers-0.5.11.0:Data.Map.Strict 40ac55e8c7db7b7f0f7e3d9769233909
import  -/  containers-0.5.11.0:Data.Map.Strict.Internal 56d73c08e046f8e159a99dc3860f1033
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  mtl-2.2.2:Control.Monad.State 1f28325cb5ef11b6b40ffadfe4bc2ca3
import  -/  mtl-2.2.2:Control.Monad.State.Class acc76e93f44ac4486524db1a327e0a0a
import  -/  text-1.2.3.0:Data.Text.Show 3b4b6fb2985a731022d67f636682da2b
import  -/  transformers-0.5.5.0:Control.Monad.Trans.State.Lazy bb07ba19cd14893d125b163b03c16c98
2b2d87544f4a13ed2a51c340634b4b40
  $dmenterBlock :: TigerCanon.Trackable w => [TigerTree.Stm] -> w ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(A,A,A,1*C1(U),A),1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ w :: * -> * ($dTrackable :: TigerCanon.Trackable w) ->
                 let {
                   $dMonad :: GHC.Base.Monad w
                   = TigerCanon.$p1Trackable @ w $dTrackable
                 } in
                 \ (b :: [TigerTree.Stm]) ->
                 case b of wild {
                   [] -> GHC.Base.return @ w $dMonad @ () GHC.Tuple.()
                   : ds ds1
                   -> case ds of wild1 {
                        DEFAULT -> GHC.Base.return @ w $dMonad @ () GHC.Tuple.()
                        TigerTree.Label s
                        -> TigerCanon.enterBlock' @ w $dTrackable s wild } }) -}
1b570b6682f2a9748d0ff36a8e3fa0ee
  $fTrackableStateT :: TigerCanon.Trackable TigerCanon.Tank
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ TigerCanon.Tank
                  (TigerCanon.$fTrackableStateT_$s$fMonadStateT
                     @ (Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]))
                  TigerCanon.$fTrackableStateT4
                    `cast`
                  (<TigerTemp.Label>_R
                   ->_R <[TigerTree.Stm]>_R
                   ->_R (<Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]>_R
                         ->_R Sym (State.N:State[0]
                                       <GHC.Integer.Type.Integer>_R
                                       <((),
                                         Data.Map.Internal.Map
                                           TigerTemp.Label
                                           [TigerTree.Stm])>_R)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                            <Data.Map.Internal.Map
                                                                               TigerTemp.Label
                                                                               [TigerTree.Stm]>_N
                                                                            <State.State
                                                                               GHC.Integer.Type.Integer>_R
                                                                            <()>_N))
                  TigerCanon.$fTrackableStateT3
                    `cast`
                  (<[TigerTree.Stm]>_R
                   ->_R (<TigerCanon.TAM>_R
                         ->_R Sym (State.N:State[0]
                                       <GHC.Integer.Type.Integer>_R
                                       <((),
                                         TigerCanon.TAM)>_R)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                         <TigerCanon.TAM>_N
                                                                         <TigerUnique.StGen>_R
                                                                         <()>_N))
                  TigerCanon.$fTrackableStateT1
                    `cast`
                  (<TigerTemp.Label>_R
                   ->_R (<Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]>_R
                         ->_R Sym (State.N:State[0]
                                       <GHC.Integer.Type.Integer>_R
                                       <(GHC.Base.Maybe [TigerTree.Stm],
                                         Data.Map.Internal.Map
                                           TigerTemp.Label
                                           [TigerTree.Stm])>_R)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                            <Data.Map.Internal.Map
                                                                               TigerTemp.Label
                                                                               [TigerTree.Stm]>_N
                                                                            <State.State
                                                                               GHC.Integer.Type.Integer>_R
                                                                            <GHC.Base.Maybe
                                                                               [TigerTree.Stm]>_N)) -}
32a8a633a1411e9b57229622754a1a7f
  $fTrackableStateT1 ::
    TigerTemp.Label
    -> Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]
    -> GHC.Integer.Type.Integer
    -> ((GHC.Base.Maybe [TigerTree.Stm],
         Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]),
        GHC.Integer.Type.Integer)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U(U,U,U)><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (l :: TigerTemp.Label)
                   (s1 :: Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm])
                   (eta :: GHC.Integer.Type.Integer) ->
                 ((TigerCanon.$fTrackableStateT2 @ [TigerTree.Stm] l s1, s1),
                  eta)) -}
524e22dc4cf03307dfa92903c145e5d6
  $fTrackableStateT2 ::
    TigerTemp.Label
    -> Data.Map.Internal.Map TigerTemp.Label a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S(SSS),1*U(U,U,U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: TigerTemp.Label)
                   (w1 :: Data.Map.Internal.Map TigerTemp.Label a) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 TigerCanon.$wpoly_go13 @ a ww1 ww2 ww3 w1 }) -}
ef175d7afd7a687e0e4c3643323f16a9
  $fTrackableStateT3 ::
    [TigerTree.Stm]
    -> TigerCanon.TAM
    -> GHC.Integer.Type.Integer
    -> (((), TigerCanon.TAM), GHC.Integer.Type.Integer)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [TigerTree.Stm])
                   (w1 :: TigerCanon.TAM)
                   (w2 :: GHC.Integer.Type.Integer) ->
                 case w of wild {
                   [] -> ((GHC.Tuple.(), w1), w2)
                   : ds ds1
                   -> case ds of wild1 {
                        DEFAULT -> ((GHC.Tuple.(), w1), w2)
                        TigerTree.Label s
                        -> ((GHC.Tuple.(),
                             case s of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                             TigerCanon.$w$sgo8 @ [TigerTree.Stm] ww1 ww2 ww3 wild w1 }),
                            w2) } }) -}
cc329ea7117d35af90dea57b08254484
  $fTrackableStateT4 ::
    TigerTemp.Label
    -> [TigerTree.Stm]
    -> Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]
    -> GHC.Integer.Type.Integer
    -> (((), Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]),
        GHC.Integer.Type.Integer)
  {- Arity: 4, Strictness: <L,1*U(U,U,U)><L,1*U><L,1*U><L,U>m,
     Unfolding: InlineRule (4, True, False)
                (\ (l :: TigerTemp.Label)
                   (b :: [TigerTree.Stm])
                   (eta :: Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm])
                   (eta1 :: GHC.Integer.Type.Integer) ->
                 ((GHC.Tuple.(),
                   TigerCanon.$fTrackableStateT_$sgo8 @ [TigerTree.Stm] l b eta),
                  eta1)) -}
2462f31d456f5905137e9b1c935c1cdb
  $fTrackableStateT_$s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (State.State GHC.Integer.Type.Integer))
                  (TigerCanon.$fTrackableStateT_$s$fFunctorStateT @ s)
                  (TigerCanon.$fTrackableStateT_$s$fApplicativeStateT_$cpure @ s)
                  (TigerCanon.$fTrackableStateT_$s$fApplicativeStateT_$c<*> @ s)
                  (Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (State.State GHC.Integer.Type.Integer)
                     @ s
                     (State.$fFunctorState @ GHC.Integer.Type.Integer)
                     (State.$fMonadState @ GHC.Integer.Type.Integer))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (State.State GHC.Integer.Type.Integer) a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (State.State GHC.Integer.Type.Integer) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <State.State GHC.Integer.Type.Integer>_R <c>_N))
                  (TigerCanon.$fTrackableStateT_$s$fApplicativeStateT_$c*> @ s)
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.State.Lazy.StateT
                             s (State.State GHC.Integer.Type.Integer) a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s (State.State GHC.Integer.Type.Integer) b)
                     (eta1 :: s) ->
                   let {
                     m :: State.State GHC.Integer.Type.Integer (a, s)
                     = x `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)
                         eta1
                   } in
                   (\ (s1 :: GHC.Integer.Type.Integer) ->
                    let {
                      ds1 :: ((a, s), GHC.Integer.Type.Integer)
                      = m `cast`
                        (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)
                          s1
                    } in
                    let {
                      ds :: (a, s) = case ds1 of wild { (,) x1 y -> x1 }
                    } in
                    let {
                      x1 :: State.State GHC.Integer.Type.Integer (b, s)
                      = eta
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)
                          (case ds of wild { (,) a1 s' -> s' })
                    } in
                    let {
                      ds2 :: ((b, s), GHC.Integer.Type.Integer)
                      = x1
                          `cast`
                        (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)
                          (case ds1 of wild { (,) x2 y -> y })
                    } in
                    ((case ds of wild { (,) a1 s' -> a1 },
                      case ds2 of wild { (,) x' s' ->
                      case x' of wild1 { (,) x2 s'' -> s'' } }),
                     case ds2 of wild { (,) x' s' -> s' }))
                     `cast`
                   (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s (State.State GHC.Integer.Type.Integer) a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (State.State GHC.Integer.Type.Integer) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)) -}
d5fbb3b825c02dea390dcab7d8fe43af
  $fTrackableStateT_$s$fApplicativeStateT_$c*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (State.State GHC.Integer.Type.Integer) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) b
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U(1*U(A,1*U),1*U)))><L,C(C1(U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (State.State GHC.Integer.Type.Integer) a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s (State.State GHC.Integer.Type.Integer) b)
                   (s1 :: s) ->
                 let {
                   x :: State.State GHC.Integer.Type.Integer (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  let {
                    ds :: ((a, s), GHC.Integer.Type.Integer)
                    = x `cast`
                      (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)
                        s2
                  } in
                  (k `cast`
                   (Control.Monad.Trans.State.Lazy.N:StateT[0]
                        <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)
                     (case ds of wild { (,) x' s' ->
                      case x' of wild1 { (,) a1 s'1 -> s'1 } }))
                    `cast`
                  (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)
                    (case ds of wild { (,) x' s' -> s' }))
                   `cast`
                 (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (State.State GHC.Integer.Type.Integer) a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s (State.State GHC.Integer.Type.Integer) b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)) -}
2eb74f32e8163549dcc66a03149bae59
  $fTrackableStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (State.State GHC.Integer.Type.Integer) (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U(1*U(1*C1(U),1*U),1*U)))><L,C(C1(U(1*U(1*U,1*U),1*U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s (State.State GHC.Integer.Type.Integer) (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s (State.State GHC.Integer.Type.Integer) a)
                   (s1 :: s) ->
                 let {
                   x :: State.State GHC.Integer.Type.Integer (a -> b, s)
                   = ds
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <State.State GHC.Integer.Type.Integer>_R <a -> b>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  let {
                    ds2 :: ((a -> b, s), GHC.Integer.Type.Integer)
                    = x `cast`
                      (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a -> b, s)>_R)
                        s2
                  } in
                  let {
                    ds3 :: (a -> b, s) = case ds2 of wild { (,) x' s' -> x' }
                  } in
                  let {
                    x1 :: State.State GHC.Integer.Type.Integer (a, s)
                    = ds1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)
                        (case ds3 of wild { (,) f s' -> s' })
                  } in
                  let {
                    ds4 :: ((a, s), GHC.Integer.Type.Integer)
                    = x1
                        `cast`
                      (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)
                        (case ds2 of wild { (,) x' s' -> s' })
                  } in
                  let {
                    ds5 :: (a, s) = case ds4 of wild { (,) x' s' -> x' }
                  } in
                  ((case ds3 of wild { (,) f s' ->
                    f (case ds5 of wild1 { (,) x2 s'' -> x2 }) },
                    case ds5 of wild { (,) x2 s'' -> s'' }),
                   case ds4 of wild { (,) x' s' -> s' }))
                   `cast`
                 (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (State.State GHC.Integer.Type.Integer) (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s (State.State GHC.Integer.Type.Integer) a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)) -}
a2be2f46c582da0c0673fac6abd7ad30
  $fTrackableStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a1 :: a) (s1 :: s) ->
                 let {
                   a2 :: (a, s) = (a1, s1)
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) -> (a2, s2))
                   `cast`
                 (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)) -}
e448af5922cf22cc12ef5059c296295d
  $fTrackableStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (State.State GHC.Integer.Type.Integer))
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ (State.State GHC.Integer.Type.Integer)
                     @ s
                     (State.$fFunctorState @ GHC.Integer.Type.Integer))
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s (State.State GHC.Integer.Type.Integer) b)
                     (eta1 :: s) ->
                   let {
                     m :: State.State GHC.Integer.Type.Integer (b, s)
                     = eta
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)
                         eta1
                   } in
                   (\ (s' :: GHC.Integer.Type.Integer) ->
                    let {
                      ds1 :: ((b, s), GHC.Integer.Type.Integer)
                      = m `cast`
                        (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)
                          s'
                    } in
                    ((x,
                      case ds1 of wild { (,) x1 y ->
                      case x1 of wild1 { (,) a1 s'1 -> s'1 } }),
                     case ds1 of wild { (,) x1 y -> y }))
                     `cast`
                   (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (State.State GHC.Integer.Type.Integer) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)) -}
484e8f6ba042c9bf12ab0408eb0ed013
  $fTrackableStateT_$s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (State.State GHC.Integer.Type.Integer))
                  (TigerCanon.$fTrackableStateT_$s$fApplicativeStateT @ s)
                  (TigerCanon.$fTrackableStateT_$s$fMonadStateT_$c>>= @ s)
                  (TigerCanon.$fTrackableStateT_$s$fMonadStateT_$c>> @ s)
                  (\ @ a (eta :: a) (eta1 :: s) ->
                   let {
                     a1 :: (a, s) = (eta, eta1)
                   } in
                   (\ (s1 :: GHC.Integer.Type.Integer) -> (a1, s1))
                     `cast`
                   (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N))
                  (TigerCanon.$fTrackableStateT_$s$fMonadStateT_$cfail @ s) -}
dd4070af66969208db12af2e0bd94c4c
  $fTrackableStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (State.State GHC.Integer.Type.Integer) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) b
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U(1*U(A,1*U),1*U)))><L,C(C1(U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (State.State GHC.Integer.Type.Integer) a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s (State.State GHC.Integer.Type.Integer) b)
                   (s1 :: s) ->
                 let {
                   x :: State.State GHC.Integer.Type.Integer (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  let {
                    ds :: ((a, s), GHC.Integer.Type.Integer)
                    = x `cast`
                      (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)
                        s2
                  } in
                  (k `cast`
                   (Control.Monad.Trans.State.Lazy.N:StateT[0]
                        <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)
                     (case ds of wild { (,) x' s' ->
                      case x' of wild1 { (,) a1 s'1 -> s'1 } }))
                    `cast`
                  (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)
                    (case ds of wild { (,) x' s' -> s' }))
                   `cast`
                 (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (State.State GHC.Integer.Type.Integer) a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s (State.State GHC.Integer.Type.Integer) b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)) -}
77403d0fa6e8ec353c72c38b86170600
  $fTrackableStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s (State.State GHC.Integer.Type.Integer) a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s (State.State GHC.Integer.Type.Integer) b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(C(U(1*U(1*U,1*U),1*U)))><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (State.State GHC.Integer.Type.Integer) a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s (State.State GHC.Integer.Type.Integer) b)
                   (s1 :: s) ->
                 let {
                   x :: State.State GHC.Integer.Type.Integer (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)
                       s1
                 } in
                 (\ (s2 :: GHC.Integer.Type.Integer) ->
                  let {
                    ds :: ((a, s), GHC.Integer.Type.Integer)
                    = x `cast`
                      (State.N:State[0] <GHC.Integer.Type.Integer>_R <(a, s)>_R)
                        s2
                  } in
                  let {
                    ds1 :: (a, s) = case ds of wild { (,) x' s' -> x' }
                  } in
                  ((k (case ds1 of wild { (,) a1 s' -> a1 }))
                     `cast`
                   (Control.Monad.Trans.State.Lazy.N:StateT[0]
                        <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)
                     (case ds1 of wild { (,) a1 s' -> s' }))
                    `cast`
                  (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)
                    (case ds of wild { (,) x' s' -> s' }))
                   `cast`
                 (Sym (State.N:State[0] <GHC.Integer.Type.Integer>_R <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (State.State GHC.Integer.Type.Integer) a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s (State.State GHC.Integer.Type.Integer) b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <State.State GHC.Integer.Type.Integer>_R <b>_N)) -}
dafbaf8deee5c8a80440354ebb712c92
  $fTrackableStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s (State.State GHC.Integer.Type.Integer) a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (State.State GHC.Integer.Type.Integer (a, s))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <State.State GHC.Integer.Type.Integer>_R <a>_N)) -}
f2f7d988bae85bc0e68d93c7eb5ac500
  $fTrackableStateT_$sgo8 ::
    TigerTemp.Label
    -> a1
    -> Data.Map.Internal.Map TigerTemp.Label a1
    -> Data.Map.Internal.Map TigerTemp.Label a1
  {- Arity: 3, Strictness: <S(SSS),1*U(U,U,U)><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: TigerTemp.Label)
                   (w1 :: a1)
                   (w2 :: Data.Map.Internal.Map TigerTemp.Label a1) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 TigerCanon.$w$sgo8 @ a1 ww1 ww2 ww3 w1 w2 }) -}
c9afeb613c988304b8ec5b5dc433f155
  $tc'C:Trackable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2456647940984851465##
                   4842318870578312554##
                   TigerCanon.$trModule
                   TigerCanon.$tc'C:Trackable2
                   1#
                   TigerCanon.$tc'C:Trackable1) -}
56a2d49b5bf7d6355584e1ab40d18e09
  $tc'C:Trackable1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f4c6a828b931cdb9e4d78bebb744ee95
  $tc'C:Trackable2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS TigerCanon.$tc'C:Trackable3) -}
2d7342943365b2100d4ce3ec2a024df9
  $tc'C:Trackable3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:Trackable"#) -}
a0ac8bc14c20baf316eba2a70ac722a4
  $tcTrackable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10841086664835526026##
                   6211399602884645051##
                   TigerCanon.$trModule
                   TigerCanon.$tcTrackable2
                   0#
                   TigerCanon.$tcTrackable1) -}
84871bfb264e3e5e131977ada1e5fdd9
  $tcTrackable1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a3890b4bacc23ce25c47b0a40598bdbc
  $tcTrackable2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS TigerCanon.$tcTrackable3) -}
5cf2b1e1033c3ef56e9071d1dc9ef8c9
  $tcTrackable3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Trackable"#) -}
29e9fc6f66db326e999ad599323f60d2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   TigerCanon.$trModule3
                   TigerCanon.$trModule1) -}
1f9c8c6497f65d4a2686f337b78b544f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS TigerCanon.$trModule2) -}
7dc70a866db4e5eb81791d1309f7ea5f
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TigerCanon"#) -}
442d150fc87bcc9a70d05557e41cb1a3
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS TigerCanon.$trModule4) -}
5b410bafa982131b876b27fb1cda2542
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("HaskTiger-0.1.0.0-ICRikAExwdr6IYW5QWtTsY"#) -}
5fa2999e6a19c22093d38d593bc67ce3
  $w$sgo8 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Internal.Map TigerTemp.Label a1
    -> Data.Map.Internal.Map TigerTemp.Label a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,1*U><S,1*U>,
     Inline: [0] -}
04b1f0c4102f112676d61319a1c74f9f
  $wlinear ::
    TigerTree.Stm
    -> [TigerTree.Stm] -> (# TigerTree.Stm, [TigerTree.Stm] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
5415f731df4ad17bf63ad923471e68f6
  $wpoly_go13 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map TigerTemp.Label a
    -> GHC.Base.Maybe a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
61ce5649a06c69c3c635392e3f0ffb5e
  $wtraceSchedule ::
    (TigerCanon.Trackable w, TigerTemp.TLGenerator w) =>
    [[TigerTree.Stm]] -> TigerTemp.Label -> w [TigerTree.Stm]
  {- Arity: 4,
     Strictness: <S(S(LLC(C(S))LL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),C(C1(U)),C(U),C(U))><L,U(A,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ w :: * -> *
                   (w1 :: TigerCanon.Trackable w)
                   (w2 :: TigerTemp.TLGenerator w)
                   (ww :: [[TigerTree.Stm]])
                   (ww1 :: TigerTemp.Label) ->
                 let {
                   $dMonad :: GHC.Base.Monad w = TigerCanon.$p1Trackable @ w w1
                 } in
                 GHC.Base.>>
                   @ w
                   $dMonad
                   @ ()
                   @ [TigerTree.Stm]
                   (let {
                      z :: w () = GHC.Base.return @ w $dMonad @ () GHC.Tuple.()
                    } in
                    letrec {
                      go :: [[TigerTree.Stm]] -> w () {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [[TigerTree.Stm]]) ->
                        case ds of wild {
                          [] -> z
                          : y ys
                          -> GHC.Base.>>
                               @ w
                               $dMonad
                               @ ()
                               @ ()
                               (TigerCanon.enterBlock @ w w1 y)
                               (go ys) }
                    } in
                    go ww)
                   (let {
                      lvl39 :: TigerTree.Stm = TigerTree.Label ww1
                    } in
                    let {
                      lvl40 :: [TigerTree.Stm]
                      = GHC.Types.: @ TigerTree.Stm lvl39 (GHC.Types.[] @ TigerTree.Stm)
                    } in
                    GHC.Base.>>=
                      @ w
                      $dMonad
                      @ [TigerTree.Stm]
                      @ [TigerTree.Stm]
                      (TigerCanon.getnext @ w w1 w2 ww)
                      (\ (ls :: [TigerTree.Stm]) ->
                       GHC.Base.return
                         @ w
                         $dMonad
                         @ [TigerTree.Stm]
                         (GHC.Base.++ @ TigerTree.Stm ls lvl40)))) -}
352b49d2d4af0b40bee791ac26c24ded
  type TAM = Data.Map.Internal.Map TigerTemp.Label [TigerTree.Stm]
3beb7a95b11a86748ed7cc5e93ffb5cf
  type Tank =
    Control.Monad.Trans.State.Lazy.StateT
      TigerCanon.TAM TigerUnique.StGen
    :: * -> *
1b570b6682f2a9748d0ff36a8e3fa0ee
  class GHC.Base.Monad w => Trackable (w :: * -> *) where
    enterBlock' :: TigerTemp.Label -> [TigerTree.Stm] -> w ()
    enterBlock :: [TigerTree.Stm] -> w ()
    getBlock :: TigerTemp.Label -> w (GHC.Base.Maybe [TigerTree.Stm])
    {-# MINIMAL enterBlock', getBlock #-}
b52988584c5a372956d5941e7c42fe6d
  basicBlocks ::
    (TigerTemp.TLGenerator w, GHC.Base.Monad w) =>
    [TigerTree.Stm] -> w ([[TigerTree.Stm]], TigerTemp.Label)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,U)><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U>,
     Unfolding: (\ @ w :: * -> *
                   ($dTLGenerator :: TigerTemp.TLGenerator w)
                   ($dMonad :: GHC.Base.Monad w)
                   (stm :: [TigerTree.Stm]) ->
                 GHC.Base.>>=
                   @ w
                   $dMonad
                   @ TigerTemp.Label
                   @ ([[TigerTree.Stm]], TigerTemp.Label)
                   (TigerTemp.newLabel @ w $dTLGenerator)
                   (\ (done :: TigerTemp.Label) ->
                    GHC.Base.>>=
                      @ w
                      $dMonad
                      @ [[TigerTree.Stm]]
                      @ ([[TigerTree.Stm]], TigerTemp.Label)
                      (TigerCanon.blocks
                         @ w
                         $dTLGenerator
                         $dMonad
                         done
                         stm
                         (GHC.Types.[] @ [TigerTree.Stm]))
                      (\ (stm' :: [[TigerTree.Stm]]) ->
                       GHC.Base.return
                         @ w
                         $dMonad
                         @ ([[TigerTree.Stm]], TigerTemp.Label)
                         (stm', done)))) -}
1544972948d53970d0a439fcc810b83d
  blocks ::
    (TigerTemp.TLGenerator w, GHC.Base.Monad w) =>
    TigerTemp.Label
    -> [TigerTree.Stm] -> [[TigerTree.Stm]] -> w [[TigerTree.Stm]]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,U)><S,U(A,C(C1(U)),A,C(U),A)><L,U><S,1*U><L,U> -}
84e5127f30397dde17bbdd1dc23d799b
  doStm ::
    (TigerTemp.TLGenerator w, GHC.Base.Monad w) =>
    TigerTree.Stm -> w TigerTree.Stm
  {- Arity: 3,
     Strictness: <L,U(U,A)><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><S,1*U> -}
83dbd8e580c149be3e089db285e6ba98
  getnext ::
    (TigerCanon.Trackable w, TigerTemp.TLGenerator w) =>
    [[TigerTree.Stm]] -> w [TigerTree.Stm]
  {- Arity: 3,
     Strictness: <S(SLLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),C(C1(U)),A,C(U))><L,U(A,U)><S,1*U> -}
7aab05f8fac5f6c6bb220ea7bbb13529
  linearize ::
    (TigerTemp.TLGenerator w, GHC.Base.Monad w) =>
    TigerTree.Stm -> w [TigerTree.Stm]
  {- Arity: 3,
     Strictness: <L,U(U,A)><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*U>,
     Unfolding: (\ @ w :: * -> *
                   ($dTLGenerator :: TigerTemp.TLGenerator w)
                   ($dMonad :: GHC.Base.Monad w)
                   (st :: TigerTree.Stm) ->
                 GHC.Base.>>=
                   @ w
                   $dMonad
                   @ TigerTree.Stm
                   @ [TigerTree.Stm]
                   (TigerCanon.doStm @ w $dTLGenerator $dMonad st)
                   (\ (s' :: TigerTree.Stm) ->
                    GHC.Base.return
                      @ w
                      $dMonad
                      @ [TigerTree.Stm]
                      (case TigerCanon.$wlinear
                              s'
                              (GHC.Types.[] @ TigerTree.Stm) of ww { (#,#) ww1 ww2 ->
                       GHC.Types.: @ TigerTree.Stm ww1 ww2 }))) -}
736ed7206659434178ce32546056b5ff
  traceSchedule ::
    (TigerCanon.Trackable w, TigerTemp.TLGenerator w) =>
    ([[TigerTree.Stm]], TigerTemp.Label) -> w [TigerTree.Stm]
  {- Arity: 3,
     Strictness: <S(S(LLC(C(S))LL)LLL),U(U(A,C(C1(U)),C(C1(U)),C(U),A),C(C1(U)),C(U),C(U))><L,U(A,U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ w :: * -> *
                   (w1 :: TigerCanon.Trackable w)
                   (w2 :: TigerTemp.TLGenerator w)
                   (w3 :: ([[TigerTree.Stm]], TigerTemp.Label)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 TigerCanon.$wtraceSchedule @ w w1 w2 ww1 ww2 }) -}
instance [safe] TigerCanon.Trackable [Control.Monad.Trans.State.Lazy.StateT]
  = TigerCanon.$fTrackableStateT
"SPEC/TigerCanon $fApplicativeStateT @ (State Integer) _" [orphan] forall @ s
                                                                          (v1 :: GHC.Base.Monad
                                                                                   (State.State
                                                                                      GHC.Integer.Type.Integer))
                                                                          (v :: GHC.Base.Functor
                                                                                  (State.State
                                                                                     GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ (State.State
                                                          GHC.Integer.Type.Integer)
                                                     @ s
                                                     v
                                                     v1
  = TigerCanon.$fTrackableStateT_$s$fApplicativeStateT @ s
"SPEC/TigerCanon $fApplicativeStateT_$c*> @ (State Integer) _" [orphan] forall @ s
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             (State.State
                                                                                                GHC.Integer.Type.Integer))
                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                               (State.State
                                                                                                  GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*> @ (State.State
                                                               GHC.Integer.Type.Integer)
                                                          @ s
                                                          $dFunctor
                                                          $dMonad
  = TigerCanon.$fTrackableStateT_$s$fApplicativeStateT_$c*> @ s
"SPEC/TigerCanon $fApplicativeStateT_$c<*> @ (State Integer) _" [orphan] forall @ s
                                                                                ($dMonad :: GHC.Base.Monad
                                                                                              (State.State
                                                                                                 GHC.Integer.Type.Integer))
                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                (State.State
                                                                                                   GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ (State.State
                                                                GHC.Integer.Type.Integer)
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = TigerCanon.$fTrackableStateT_$s$fApplicativeStateT_$c<*> @ s
"SPEC/TigerCanon $fApplicativeStateT_$cpure @ (State Integer) _" [orphan] forall @ s
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               (State.State
                                                                                                  GHC.Integer.Type.Integer))
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 (State.State
                                                                                                    GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ (State.State
                                                                 GHC.Integer.Type.Integer)
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = TigerCanon.$fTrackableStateT_$s$fApplicativeStateT_$cpure @ s
"SPEC/TigerCanon $fFunctorStateT @ (State Integer) _" [orphan] forall @ s
                                                                      (v :: GHC.Base.Functor
                                                                              (State.State
                                                                                 GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ (State.State
                                                      GHC.Integer.Type.Integer)
                                                 @ s
                                                 v
  = TigerCanon.$fTrackableStateT_$s$fFunctorStateT @ s
"SPEC/TigerCanon $fMonadStateT @ (State Integer) _" [orphan] forall @ s
                                                                    (v :: GHC.Base.Monad
                                                                            (State.State
                                                                               GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ (State.State
                                                    GHC.Integer.Type.Integer)
                                               @ s
                                               v
  = TigerCanon.$fTrackableStateT_$s$fMonadStateT @ s
"SPEC/TigerCanon $fMonadStateT_$c>> @ (State Integer) _" [orphan] forall @ s
                                                                         ($dMonad :: GHC.Base.Monad
                                                                                       (State.State
                                                                                          GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (State.State
                                                         GHC.Integer.Type.Integer)
                                                    @ s
                                                    $dMonad
  = TigerCanon.$fTrackableStateT_$s$fMonadStateT_$c>> @ s
"SPEC/TigerCanon $fMonadStateT_$c>>= @ (State Integer) _" [orphan] forall @ s
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        (State.State
                                                                                           GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (State.State
                                                          GHC.Integer.Type.Integer)
                                                     @ s
                                                     $dMonad
  = TigerCanon.$fTrackableStateT_$s$fMonadStateT_$c>>= @ s
"SPEC/TigerCanon $fMonadStateT_$cfail @ (State Integer) _" [orphan] forall @ s
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         (State.State
                                                                                            GHC.Integer.Type.Integer))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (State.State
                                                           GHC.Integer.Type.Integer)
                                                      @ s
                                                      $dMonad
  = TigerCanon.$fTrackableStateT_$s$fMonadStateT_$cfail @ s
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

